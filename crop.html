<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Free, fast, and private PDF & Image tools — everything runs in your browser (no uploads).">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Crop PDF — Client-side</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="stylesheet" href="/style.css" />
  <script defer src="/site.js"></script>
  <script defer src="/assets/seo.js"></script>
  <meta name="color-scheme" content="light dark" />
  <style>
    /* ===== Layout tweaks for compact look (only this page) ===== */
    .crop-wrap .panel .grid-crop{
      display:grid;grid-template-columns:320px 1fr 320px;gap:20px;align-items:start
    }
    /* FIRST BOX: compact header row */
    .upload-box{padding:16px}
    .upload-box .btn-row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:6px}
    .upload-box .pill#meta{padding:8px 12px;line-height:1;white-space:nowrap}
    .upload-box .muted{margin:6px 0 4px}
    .thumbs.small{display:flex;flex-direction:column;gap:10px;max-height:58vh;overflow:auto;padding-right:4px}
    .thumbs.small .thumb{border:1px solid var(--border);border-radius:10px;padding:6px;box-shadow:var(--shadow-sm);cursor:pointer;background:var(--surface-1)}
    .thumbs.small .thumb.active{outline:2px solid var(--brand-1)}

    /* MIDDLE STAGE */
    .stage-wrap{position:relative;display:block;margin:8px auto 0;max-width:100%}
    .stage-wrap canvas{display:none;max-width:100%;height:auto;border-radius:12px;background:var(--surface-2);outline:2px solid rgba(0,0,0,.10);box-shadow:var(--shadow-sm)}
    .stage-wrap.ready canvas{display:block}
    .overlay-crop{position:absolute;inset:0;pointer-events:none;border-radius:12px}
    .overlay-crop .rect{position:absolute;border:2px dashed rgba(124,58,237,.9);background:rgba(124,58,237,.08);border-radius:10px;display:none;box-shadow:0 0 0 2px rgba(255,255,255,.35) inset;cursor:move;pointer-events:auto}
    .overlay-crop .handle{position:absolute;width:12px;height:12px;background:#fff;border:2px solid #7c3aed;border-radius:50%;box-shadow:0 1px 2px rgba(0,0,0,.2);pointer-events:auto}
    .overlay-crop .handle.nw,.overlay-crop .handle.se{cursor:nwse-resize}
    .overlay-crop .handle.ne,.overlay-crop .handle.sw{cursor:nesw-resize}
    .overlay-crop .handle.n,.overlay-crop .handle.s{cursor:ns-resize}
    .overlay-crop .handle.w,.overlay-crop .handle.e{cursor:ew-resize}

    /* THIRD BOX: compact controls (like Compress panel height) */
    .controls-box{padding:16px}
    .controls-box .settings-actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .controls-box details{margin-top:6px}
    .controls-box .title{margin-bottom:6px}

    @media (max-width:1024px){
      .crop-wrap .panel .grid-crop{grid-template-columns:1fr}
      .thumbs.small{flex-direction:row;flex-wrap:wrap;max-height:none}
    }
  </style>
</head>
<body>
<header class="site-header">
  <div class="container bar">
    <div class="brand"><span class="logo"></span><span>PDF &amp; Image Tools</span></div>
    <div class="container tool-tabs-wrap">
      <button class="tool-scroll tool-left" aria-label="Scroll tools left" title="Scroll left">‹</button>
      <nav class="tool-tabs" role="navigation" aria-label="Tools">
        <a href="/merge">Merge PDF</a><a href="/delete-pages">Delete pages</a><a href="/rotate-pages">Rotate PDF</a>
        <a href="/reorder-pages">Reorder PDF</a><a href="/crop" class="active">Crop PDF</a><a href="/compress">Compress PDF</a>
        <a href="/pdf-to-images">PDF → Images</a><a href="/image-to-pdf">Image → PDF</a><a href="/jpg-to-png">JPG → PNG</a><a href="/png-to-jpg">PNG → JPG</a>
      </nav>
      <button class="tool-scroll tool-right" aria-label="Scroll tools right" title="Scroll right">›</button>
    </div>
  </div>
</header>

<main>
  <div class="wrap crop-wrap">
    <aside class="panel">
      <div class="grid-crop">
        <!-- ============ 1) Upload PDF (compact) ============ -->
        <section class="panel card box upload-box theme-center" id="dropzone" aria-label="Upload">
          <h2 class="title">Upload</h2>
          <p class="muted">Drag &amp; drop PDF here</p>

          <div class="btn-row">
            <label for="file" class="btn gradient">Browse PDF</label>
            <div class="pill" id="meta">No file</div>
            <button class="btn subtle" id="clearBtnTop" disabled>Clear</button>
          </div>

          <div class="small muted">Everything runs in your browser (no uploads).</div>
          <div class="rule soft mt-2"></div>

          <!-- thumbnails (no label/placeholder) -->
          <div id="thumbs" class="thumbs small" aria-live="polite"></div>

          <input id="file" type="file" accept="application/pdf" hidden />
        </section>

        <!-- ============ 2) Settings (canvas stays same) ============ -->
        <section class="panel card box action-box theme-center" aria-label="Setting">
          <h2 class="title">Setting</h2>
          <progress id="prog" max="100" value="0" class="w-100"></progress>
          <div id="status" class="small">Idle…</div>
          <div class="stage-wrap mt-2" id="stageWrap" tabindex="0" aria-label="Page preview">
            <canvas id="stage" width="0" height="0"></canvas>
            <div class="overlay-crop" aria-hidden="true">
              <div class="rect" id="rect">
                <div class="handle nw" data-h="nw"></div>
                <div class="handle ne" data-h="ne"></div>
                <div class="handle sw" data-h="sw"></div>
                <div class="handle se" data-h="se"></div>
                <div class="handle n"  data-h="n"></div>
                <div class="handle s"  data-h="s"></div>
                <div class="handle w"  data-h="w"></div>
                <div class="handle e"  data-h="e"></div>
              </div>
            </div>
          </div>
        </section>

        <!-- ============ 3) Download Crop PDF (compact like Compress) ============ -->
        <section class="panel card box theme-center controls-box" aria-label="Download">
          <h2 class="title">Download</h2>

          <label class="inline" for="applyAll">
            <input id="applyAll" type="checkbox" checked />
            <span>Apply crop to all pages</span>
          </label>

          <details>
            <summary>Advanced</summary>
            <div class="small muted mt-1">
              • Drag to draw a crop box. Drag inside to move; use handles to resize.<br>
              • Shift while resizing = keep aspect ratio.<br>
              • Arrows to nudge (1px), Shift+Arrows = 10px, Ctrl+Arrows = resize.<br>
              • Press <kbd>Esc</kbd> to clear. Preview is non-destructive; use “Back to original”.
            </div>
          </details>

          <div class="settings-actions">
            <button id="clearCrop" class="btn ghost" disabled>Clear selection (Esc)</button>
            <button id="applyCrop" class="btn" disabled>Preview crop</button>
            <button id="backOriginal" class="btn subtle back-link" title="Back to original">Back to original</button>
            <button id="downloadBtn" class="btn" disabled>Download New PDF</button>
          </div>
        </section>
      </div>
    </aside>

    <!-- Title + How it works (unchanged) -->
    <main class="panel">
      <h1 class="page-title">Crop PDF</h1>
      <p class="sub">3 steps: Upload • Pick page • Draw/adjust crop • Preview &amp; Download. All processing stays on your device.</p>

      <section class="card mt-3">
        <h2 class="title">How it works</h2>
        <ul class="sub">
          <li>Each page is rendered to an image via <strong>PDF.js</strong>, then rebuilt as a compact PDF with <strong>pdf-lib</strong>.</li>
          <li>Great for scans/photos. Text-only PDFs may not shrink much.</li>
          <li>If the compressed file is larger and “Keep original” is ON, we serve the original.</li>
        </ul>
        <p class="sub mt-1">Privacy: No uploads. Everything stays on your device.</p>
      </section>
    </main>
  </div>

  <!-- libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";</script>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

  <script>
    const $ = (s) => document.querySelector(s);

    // elements
    const fileInput=$('#file'), metaEl=$('#meta'), clearBtnTop=$('#clearBtnTop'), dropzone=$('#dropzone');
    const stage=$('#stage'), stageWrap=$('#stageWrap'), overlayRect=$('#rect'), thumbsEl=$('#thumbs');
    const applyAllEl=$('#applyAll'), clearBtn=$('#clearCrop'), applyBtn=$('#applyCrop'), backBtn=$('#backOriginal'), downloadBtn=$('#downloadBtn');
    const prog=$('#prog'), statusEl=$('#status');

    // state
    let pdfDocJS=null, pageCount=0, currentPage=1, currentViewport=null;
    let pageRenderTask=null;
    let selection=null, dragMode=null, activeHandle=null, dragStart=null, lastPos=null;
    let lockRatio=null;

    // original / preview bytes
    let originalBytes=null;
    let previewBytes=null;
    let activeDoc = 'original'; // 'original' | 'preview'

    let outFileNameBase='cropped';

    const savedPctByPage = new Map();
    let lastTemplatePct = null;

    function fmt(n){return new Intl.NumberFormat().format(n);}
    function setStatus(t){statusEl.textContent=t;}
    function enableControls(on){
      applyAllEl.disabled=!on; downloadBtn.disabled=!on; clearBtnTop.disabled=!on;
      downloadBtn.classList.toggle('primary-blue', !!on);
    }
    function cancelActiveRender(){ if(pageRenderTask?.cancel){ try{pageRenderTask.cancel()}catch{} } pageRenderTask=null; }

    function bytesForActive(){
      const src = (activeDoc==='preview' ? previewBytes : originalBytes);
      return src ? src.slice() : null;
    }
    async function getActiveJsDoc(){
      const data=bytesForActive(); if(!data) throw new Error('No PDF loaded');
      return await pdfjsLib.getDocument({data}).promise;
    }

    // upload/reset
    fileInput.addEventListener('change',async e=>{const f=e.target.files?.[0];if(f)await handleFile(f);});
    clearBtnTop.addEventListener('click', resetDocState);
    ['dragenter','dragover'].forEach(ev=>dropzone.addEventListener(ev,e=>{e.preventDefault();dropzone.classList.add('dropping');}));
    ['dragleave','drop'].forEach(ev=>dropzone.addEventListener(ev,e=>{e.preventDefault();dropzone.classList.remove('dropping');}));
    dropzone.addEventListener('drop',async e=>{
      const f=e.dataTransfer?.files?.[0]; if(!f) return;
      if(!/application\/pdf/.test(f.type) && !/\.pdf$/i.test(f.name)) return alert('Please drop a PDF file.');
      await handleFile(f);
    });

    function resetDocState(){
      cancelActiveRender();
      fileInput.value='';
      pdfDocJS=null; pageCount=0; currentPage=1; currentViewport=null;
      stage.width=stage.height=0; stageWrap.classList.remove('ready');
      thumbsEl.innerHTML='';
      metaEl.textContent='No file'; metaEl.title='';
      enableControls(false); setStatus('Idle…');
      selection=null; overlayRect.style.display='none';
      prog.value=0;
      originalBytes=null; previewBytes=null; activeDoc='original'; backBtn.classList.remove('show');
      applyAllEl.checked=true;
      savedPctByPage.clear(); lastTemplatePct=null;
    }

    async function handleFile(file){
      try{
        setStatus('Loading PDF…'); enableControls(false);
        selection=null; overlayRect.style.display='none'; cancelActiveRender();

        const cleanBase=(file.name||'document.pdf').replace(/\.pdf$/i,'');
        outFileNameBase=cleanBase;
        metaEl.textContent = `${file.name} • loading…`; metaEl.title=metaEl.textContent;

        originalBytes = new Uint8Array(await file.arrayBuffer());
        previewBytes = null; activeDoc='original';

        const doc = await pdfjsLib.getDocument({ data: originalBytes.slice() }).promise;
        pdfDocJS=doc; pageCount=pdfDocJS.numPages;
        metaEl.textContent = `${file.name} • ${pageCount} pages`; // short text to keep one row
        metaEl.title = `${file.name} • ${pageCount} pages`;

        await rebuildThumbs(doc);
        await setPage(1, doc);
        enableControls(true); setStatus('Ready.');
      }catch(err){ console.error(err); alert('PDF load failed: '+(err?.message||err)); setStatus('Error loading PDF.'); }
    }

    function computeFitScale(page){
      const v1=page.getViewport({scale:1});
      const centerWidth=stageWrap.clientWidth||stageWrap.getBoundingClientRect().width||800;
      const targetW=Math.max(240, centerWidth*0.98);
      const targetH=Math.max(260, Math.floor(window.innerHeight*0.72));
      return Math.min(targetW/v1.width, targetH/v1.height);
    }

    async function setPage(n, providedDoc=null){
      currentPage=n;
      Array.from(thumbsEl.children).forEach((el,i)=>el.classList.toggle('active', i===n-1));

      const doc=providedDoc||await getActiveJsDoc(); pdfDocJS=doc;
      const page=await pdfDocJS.getPage(n);
      stageWrap.classList.remove('ready');

      const scale=computeFitScale(page);
      currentViewport=page.getViewport({scale});
      const dpr=Math.max(1,window.devicePixelRatio||1);
      stage.width=Math.ceil(currentViewport.width*dpr);
      stage.height=Math.ceil(currentViewport.height*dpr);
      stage.style.width=Math.ceil(currentViewport.width)+'px';
      stage.style.height=Math.ceil(currentViewport.height)+'px';

      const ctx=stage.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.clearRect(0,0,stage.width,stage.height);

      cancelActiveRender();
      pageRenderTask=page.render({canvasContext:ctx,viewport:currentViewport});
      try{await pageRenderTask.promise;}catch(e){if(e?.name!=='RenderingCancelledException')throw e;}finally{pageRenderTask=null;}
      stageWrap.classList.add('ready'); page.cleanup();

      const cssW=parseFloat(stage.style.width)||stage.width, cssH=parseFloat(stage.style.height)||stage.height;
      if(activeDoc==='preview'){
        selection=null;
      }else{
        const savedPct=savedPctByPage.get(currentPage);
        if(savedPct){
          selection = pctToSel(savedPct, cssW, cssH);
        }else if(lastTemplatePct){
          const w=lastTemplatePct.w*cssW, h=lastTemplatePct.h*cssH;
          selection = { x: Math.max(0,(cssW-w)/2), y: Math.max(0,(cssH-h)/2), w, h };
        }else{
          selection=null;
        }
      }
      updateRectUI();

      const ok=selection && selection.w>=2 && selection.h>=2;
      clearBtn.disabled=!ok; applyBtn.disabled=!ok;

      stageWrap.scrollIntoView({block:'center', inline:'nearest'});
    }
    window.addEventListener('resize',()=>{ if(bytesForActive()) setPage(currentPage); });

    async function rebuildThumbs(providedDoc=null){
      const doc=providedDoc||await getActiveJsDoc(); const pages=doc.numPages;
      thumbsEl.innerHTML='';
      for(let i=1;i<=pages;i++){
        const p=await doc.getPage(i); const v=p.getViewport({scale:.22});
        const c=document.createElement('canvas'); const ctx=c.getContext('2d'); c.width=v.width; c.height=v.height;
        await p.render({canvasContext:ctx,viewport:v}).promise; p.cleanup();
        const holder=document.createElement('div'); holder.className='thumb'; if(i===currentPage) holder.classList.add('active');
        holder.appendChild(c); holder.title='Page '+i; holder.addEventListener('click',()=>setPage(i)); thumbsEl.appendChild(holder);
      }
    }

    const HANDLE_HIT=10;
    function getLocalXY(evt){const r=stage.getBoundingClientRect();return{ x:Math.max(0,Math.min(r.width,evt.clientX-r.left)), y:Math.max(0,Math.min(r.height,evt.clientY-r.top)) };}
    function normalizeSel(sel){
      let {x,y,w,h}=sel;
      if(w<0){x+=w; w=-w;} if(h<0){y+=h; h=-h;}
      const maxW=parseFloat(stage.style.width)||stage.width, maxH=parseFloat(stage.style.height)||stage.height;
      x=Math.max(0,Math.min(x,maxW-w)); y=Math.max(0,Math.min(y,maxH-h));
      w=Math.max(1,Math.min(w,maxW-x)); h=Math.max(1,Math.min(h,maxH-y));
      return{x,y,w,h};
    }
    function placeHandles(sel){
      const pos={ nw:[0,0], ne:[sel.w,0], sw:[0,sel.h], se:[sel.w,sel.h],
        n:[sel.w/2,0], s:[sel.w/2,sel.h], w:[0,sel.h/2], e:[sel.w,sel.h/2] };
      overlayRect.querySelectorAll('.handle').forEach(h=>{
        const [hx,hy]=pos[h.dataset.h]; h.style.left=(hx-6)+'px'; h.style.top=(hy-6)+'px';
      });
    }
    function updateRectUI(){
      if(!selection){overlayRect.style.display='none';clearBtn.disabled=true;applyBtn.disabled=true;return;}
      const s=selection;
      const offX = stage.offsetLeft || 0;
      const offY = stage.offsetTop  || 0;
      overlayRect.style.display='block';
      overlayRect.style.left  = (offX + s.x)+'px';
      overlayRect.style.top   = (offY + s.y)+'px';
      overlayRect.style.width = s.w+'px';
      overlayRect.style.height= s.h+'px';
      placeHandles(s);
      const ok = s.w>=2 && s.h>=2; clearBtn.disabled=!ok; applyBtn.disabled=!ok;
    }
    function selToPct(sel, cssW, cssH){ return { x:sel.x/cssW, y:sel.y/cssH, w:sel.w/cssW, h:sel.h/cssH }; }
    function pctToSel(p, cssW, cssH){ return { x:p.x*cssW, y:p.y*cssH, w:p.w*cssW, h:p.h*cssH }; }
    function persistSelection(){
      if(!selection || activeDoc==='preview') return;
      const cssW=parseFloat(stage.style.width)||stage.width, cssH=parseFloat(stage.style.height)||stage.height;
      const pct = selToPct(selection, cssW, cssH);
      savedPctByPage.set(currentPage, pct);
      lastTemplatePct = { w:pct.w, h:pct.h };
    }

    function startDraw(e){
      if(!currentViewport) return;
      const pt=getLocalXY(e);
      dragMode='draw'; dragStart=pt; selection={x:pt.x,y:pt.y,w:0,h:0}; lockRatio=null; updateRectUI();
    }
    stageWrap.addEventListener('mousedown',startDraw);
    stage.addEventListener('mousedown',startDraw);

    overlayRect.addEventListener('mousedown',e=>{
      if(!selection) return; e.preventDefault(); e.stopPropagation();
      const pt=getLocalXY(e);
      const centers={
        nw:[selection.x,selection.y], ne:[selection.x+selection.w,selection.y],
        sw:[selection.x,selection.y+selection.h], se:[selection.x+selection.w,selection.y+selection.h],
        n:[selection.x+selection.w/2,selection.y], s:[selection.x+selection.w/2,selection.y+selection.h],
        w:[selection.x,selection.y+selection.h/2], e:[selection.x+selection.w,selection.y+selection.h/2]
      };
      let found=null; for(const k in centers){const [hx,hy]=centers[k]; if(Math.abs(pt.x-hx)<=HANDLE_HIT&&Math.abs(pt.y-hy)<=HANDLE_HIT){found=k;break;}}
      if(found){ dragMode='resize'; activeHandle=found; lastPos=pt; lockRatio=(e.shiftKey? (selection.w/selection.h||1):null); return; }
      dragMode='move'; lastPos=pt; lockRatio=null;
    });

    window.addEventListener('mousemove',e=>{
      if(!dragMode) return;
      const pt=getLocalXY(e);
      const maxW=parseFloat(stage.style.width)||stage.width, maxH=parseFloat(stage.style.height)||stage.height;

      if(dragMode==='draw'){
        selection.w=pt.x-dragStart.x; selection.h=pt.y-dragStart.y;
        selection=normalizeSel(selection); updateRectUI(); return;
      }
      if(dragMode==='move'){
        const dx=pt.x-lastPos.x, dy=pt.y-lastPos.y;
        let nx=Math.max(0,Math.min(selection.x+dx,maxW-selection.w));
        let ny=Math.max(0,Math.min(selection.y+dy,maxH-selection.h));
        selection={x:nx,y:ny,w:selection.w,h:selection.h}; lastPos=pt; updateRectUI(); return;
      }
      if(dragMode==='resize'){
        let x1=selection.x, y1=selection.y, x2=selection.x+selection.w, y2=selection.y+selection.h;
        const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
        if(['nw','w','sw'].includes(activeHandle)) x1=clamp(pt.x,0,x2-1);
        if(['ne','e','se'].includes(activeHandle)) x2=clamp(pt.x,x1+1,maxW);
        if(['nw','n','ne'].includes(activeHandle)) y1=clamp(pt.y,0,y2-1);
        if(['sw','s','se'].includes(activeHandle)) y2=clamp(pt.y,y1+1,maxH);

        let next={x:x1,y:y1,w:x2-x1,h:y2-y1};
        const keepRatio = e.shiftKey || lockRatio;
        const ratio = lockRatio || (selection.w/selection.h || 1);
        if(keepRatio){
          if(['n','s'].includes(activeHandle)){ next.w = next.h*ratio; if(activeHandle==='n') next.x=x2-next.w; }
          else if(['e','w'].includes(activeHandle)){ next.h = next.w/ratio; if(activeHandle==='w') next.y=y2-next.h; }
          else{
            const w1=next.w, h1=w1/ratio;
            const h2=next.h, w2=h2*ratio;
            if(activeHandle==='nw'||activeHandle==='ne'){
              if(h1<=next.h){ next.h=h1; if(activeHandle==='nw') next.y=y2-next.h; }
              else { next.w=w2; if(activeHandle==='ne') next.x=x2-next.w; }
            }else{
              if(h1<=next.h){ next.h=h1; }
              else { next.w=w2; }
            }
          }
        }
        selection=normalizeSel(next); lastPos=pt; updateRectUI(); return;
      }
    });

    window.addEventListener('mouseup',()=>{ if(!dragMode) return; dragMode=null; activeHandle=null; dragStart=null; updateRectUI(); persistSelection(); });

    window.addEventListener('keydown',e=>{
      if(e.key==='Escape'){ e.preventDefault(); clearSelectionUI(); return; }
      if(!selection) return;
      const moveStep = e.shiftKey ? 10 : 1;
      const resizeStep = e.shiftKey ? 10 : 1;
      const cssW=parseFloat(stage.style.width)||stage.width, cssH=parseFloat(stage.style.height)||stage.height;
      let handled=false;
      if(!e.ctrlKey){
        if(e.key==='ArrowLeft'){ selection.x=Math.max(0, selection.x-moveStep); handled=true; }
        if(e.key==='ArrowRight'){ selection.x=Math.min(cssW-selection.w, selection.x+moveStep); handled=true; }
        if(e.key==='ArrowUp'){ selection.y=Math.max(0, selection.y-moveStep); handled=true; }
        if(e.key==='ArrowDown'){ selection.y=Math.min(cssH-selection.h, selection.y+moveStep); handled=true; }
      }else{
        if(e.key==='ArrowRight'){ selection.w=Math.min(cssW-selection.x, selection.w+resizeStep); handled=true; }
        if(e.key==='ArrowLeft'){ selection.w=Math.max(1, selection.w-resizeStep); handled=true; }
        if(e.key==='ArrowDown'){ selection.h=Math.min(cssH-selection.y, selection.h+resizeStep); handled=true; }
        if(e.key==='ArrowUp'){ selection.h=Math.max(1, selection.h-resizeStep); handled=true; }
      }
      if(handled){ e.preventDefault(); selection=normalizeSel(selection); updateRectUI(); persistSelection(); }
    });

    function clearSelectionUI(){
      selection=null; overlayRect.style.display='none';
      clearBtn.disabled=true; applyBtn.disabled=true;
      savedPctByPage.delete(currentPage);
    }

    clearBtn.addEventListener('click', clearSelectionUI);

    async function buildCroppedBytes(sel, scope){
      const work = await PDFLib.PDFDocument.load(originalBytes.slice());
      const pages = work.getPages();
      const refPage = pages[currentPage-1];
      const { width: pdfW, height: pdfH } = refPage.getSize();
      const cssW = parseFloat(stage.style.width), cssH = parseFloat(stage.style.height);
      const scaleX = pdfW/cssW, scaleY = pdfH/cssH;

      const cropX = sel.x * scaleX, cropW = sel.w * scaleX;
      const cropY = (pdfH - (sel.y + sel.h) * scaleY), cropH = sel.h * scaleY;

      const applyTo = (p)=>{
        const w=Math.max(1,Math.min(cropW,p.getWidth()));
        const h=Math.max(1,Math.min(cropH,p.getHeight()));
        const x=Math.max(0,Math.min(cropX,p.getWidth()-w));
        const y=Math.max(0,Math.min(cropY,p.getHeight()-h));
        p.setCropBox(x,y,w,h); p.setMediaBox(x,y,w,h);
        if(p.setBleedBox)p.setBleedBox(x,y,w,h); if(p.setTrimBox)p.setTrimBox(x,y,w,h); if(p.setArtBox)p.setArtBox(x,y,w,h);
      };

      if(scope==='all'){ pages.forEach(applyTo); } else { applyTo(refPage); }
      return await work.save({updateFieldAppearances:false});
    }

    // preview
    applyBtn.addEventListener('click', async ()=>{
      try{
        if(activeDoc!=='original'){ alert('Already in preview. Use “Back to original” to reset.'); return; }
        if(!originalBytes){ alert('Please upload a PDF first.'); return; }
        if(!selection || selection.w<2 || selection.h<2){ setStatus('Draw a crop box first.'); return; }
        const sel={...selection};
        prog.style.display='block'; prog.value=5; setStatus('Building preview…');

        previewBytes = await buildCroppedBytes(sel, applyAllEl.checked ? 'all' : 'current');
        prog.value=60;

        activeDoc='preview';
        lastTemplatePct = null;
        selection = null;
        overlayRect.style.display='none';
        clearBtn.disabled=true; applyBtn.disabled=true;
        backBtn.classList.add('show');

        await rebuildThumbs(); prog.value=90;
        await setPage(currentPage);
        setStatus('Preview ready');
        prog.value=100; setTimeout(()=>prog.style.display='none',200);
      }catch(err){ console.error(err); alert('Preview failed: '+(err?.message||err)); setStatus('Preview failed'); prog.style.display='none'; }
    });

    backBtn.addEventListener('click', async ()=>{
      if(!originalBytes) return;
      activeDoc='original';
      backBtn.classList.remove('show');
      await rebuildThumbs(); await setPage(currentPage);
      setStatus('Back to original');
    });

    // download
    downloadBtn.addEventListener('click', async ()=>{
      if(!originalBytes){ return; }
      if(!selection){ alert('Draw a crop box first.'); return; }
      setStatus('Preparing download…'); prog.style.display='block'; prog.value=10;
      const finalBytes = await buildCroppedBytes(selection, applyAllEl.checked ? 'all' : 'current');
      prog.value=70;
      const blob=new Blob([finalBytes],{type:'application/pdf'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url;
      a.download = applyAllEl.checked ? `${outFileNameBase}.cropped.pdf` : `${outFileNameBase}-p${currentPage}.cropped.pdf`;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(url),1500);
      prog.value=100; setTimeout(()=>prog.style.display='none',200);
      setStatus('Done.');
    });

    // init
    resetDocState();
  </script>
</main>
</body>
</html>
